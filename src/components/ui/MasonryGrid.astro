---
export interface Props {
  cols?: number;
  colsSm?: number;
  colsLg: number;
  itemWidth?: string;
  gap?: string;
  class?: string;
}

const {
  cols = 2,
  colsSm = 3,
  colsLg,
  itemWidth = "20rem",
  gap = "1rem",
  class: className = "",
} = Astro.props;

// Generate unique ID for scoped styling
const uniqueId = `masonry-${Math.random().toString(36).slice(2, 9)}`;
---

<Fragment set:html={`<style>
  masonry-list[data-masonry-id="${uniqueId}"] {
    column-gap: var(--masonry-list-column-gap, 1rem);
    row-gap: var(--masonry-list-row-gap, 1rem);
  }

  @supports (display: grid-lanes) {
    masonry-list[data-masonry-id="${uniqueId}"] {
      display: grid-lanes;
      grid-template-columns: repeat(${cols}, 1fr);
    }

    @media (min-width: 640px) {
      masonry-list[data-masonry-id="${uniqueId}"] {
        grid-template-columns: repeat(${colsSm}, 1fr);
      }
    }

    @media (min-width: 1024px) {
      masonry-list[data-masonry-id="${uniqueId}"] {
        grid-template-columns: repeat(${colsLg}, 1fr);
      }
    }
  }

  @supports not (display: grid-lanes) {
    masonry-list[data-masonry-id="${uniqueId}"] {
      display: grid;
      grid-template-columns: repeat(${cols}, 1fr);
      grid-auto-flow: dense;
    }

    @media (min-width: 640px) {
      masonry-list[data-masonry-id="${uniqueId}"] {
        grid-template-columns: repeat(${colsSm}, 1fr);
      }
    }

    @media (min-width: 1024px) {
      masonry-list[data-masonry-id="${uniqueId}"] {
        grid-template-columns: repeat(${colsLg}, 1fr);
      }
    }

    masonry-list[data-masonry-id="${uniqueId}"] masonry-item {
      align-self: start;
      grid-column-end: span var(--masonry-item-span, 1);
    }
  }
</style>`} />

<masonry-list
  data-masonry-id={uniqueId}
  style={`--masonry-item-width: ${itemWidth}; --masonry-list-column-gap: ${gap}; --masonry-list-row-gap: ${gap}; --masonry-item-max-span: 1;`}
  class={className}
>
  <slot />
</masonry-list>

<script>
  class MasonryList extends HTMLElement {
    #patched = false;

    get patched() {
      return this.#patched;
    }
    connectedCallback() {
      if (CSS.supports("display", "grid-lanes")) return;
      const style = getComputedStyle(this);
      if (style.gridTemplateRows === "masonry") return;
      this.#patched = true;
      this.style.gridAutoRows = "0px";
      this.style.setProperty(
        "--masonry-list-row-gap",
        `${Math.round(parseFloat(style.rowGap))}`,
      );
      this.style.setProperty("row-gap", "1px", "important");
    }
  }

  class MasonryItem extends HTMLElement {
    #observer: ResizeObserver | null = null;
    #layout = () => {
      const { height } = this.getBoundingClientRect();
      this.style.gridRowEnd = `span calc(${Math.round(height)} + var(--masonry-list-row-gap))`;
    };
    connectedCallback() {
      const masonry = this.closest("masonry-list") as MasonryList | null;
      if (!masonry?.patched) return;
      this.#observer = new ResizeObserver(this.#layout);
      this.#observer.observe(this);
      this.#layout();
    }
    disconnectedCallback() {
      this.#observer?.disconnect();
    }
  }

  if (typeof window !== "undefined") {
    if (!customElements.get("masonry-list")) {
      customElements.define("masonry-list", MasonryList);
    }
    if (!customElements.get("masonry-item")) {
      customElements.define("masonry-item", MasonryItem);
    }
  }
</script>
