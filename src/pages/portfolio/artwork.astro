---
// Server-side code, as before
import { Image } from "astro:assets";
import BaseLayout from '@/layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';
import type { ImageMetadata } from 'astro';

const titleShort = "art";
const titleFull = "artwork";

const artwork = await getCollection('artwork');
const artworkItems = artwork.map(item => item.data);
artworkItems.sort((a, b) => (new Date(b.created) > new Date(a.created) ? 1 : -1));

const allTags = [...new Set(artworkItems.flatMap(a => a.art_tags ?? []))].map(formatTag).sort();

function formatTag(tag: string): string {
  if (!tag) return '';
  return tag.replace(/-/g, ' ');
}

const imageImports = import.meta.glob<{ default: ImageMetadata }>("../../content/300-collections/portfolio/images/*");

const artworkItemsWithImports = await Promise.all(
  artworkItems.map(async item => {
    let imgData = null;
    const imageFileName = item.image ? item.image.replace(/^.*images\//, '') : "";
    const globKey = `../../content/300-collections/portfolio/images/${imageFileName}`;
    if (imageImports[globKey]) {
      imgData = (await imageImports[globKey]()).default;
    } else {
      console.warn('Image not found via import.meta.glob mapping:', globKey);
    }
    return { ...item, imgData };
  })
);
---

<BaseLayout titleShort={titleShort} titleFull={titleFull}>
  <div class="container mx-auto px-4 py-6">
    <!-- Filter Controls -->
    <div class="pb-6 flex justify-center items-center gap-1.5 md:gap-3 flex-wrap text-base max-w-9/10 sm:max-w-3/4 mx-auto">
      <span class="font-base font-semibold text-content-0">filter to</span>
      {allTags.map((tag) => (
        <button
          class="filter-button px-2 py-1 md:px-3 md:py-2 rounded-full text-base font-base font-light lowercase soft-transition focus-outline bg-surface-1 text-content-2"
          data-tag={tag}
          type="button"
        >{tag}
        </button>
      ))}
    </div>

    <!-- Masonry List -->
    <masonry-list
      style="--masonry-item-width: 20rem; --masonry-list-column-gap: 1rem; --masonry-list-row-gap: 1rem; --masonry-item-max-span: 1;"
      class="max-w-9/10 sm:max-w-3/4 mx-auto"
    >
      {artworkItemsWithImports.map((item, index) => (
        <masonry-item
          class="rounded-md relative group mb-2 md:mb-3 w-full h-auto"
          data-tags={item.art_tags?.map(formatTag).join(',') ?? ""}
        >
          {item.imgData && (
            <Image
              src={item.imgData}
              alt={item.description ?? item.title ?? "artwork"}
              loading={index < 20 ? "eager" : "lazy"}
              style="width:100%; height:auto; border-radius:0.375rem;"
            />
            <div class="absolute rounded-md inset-0 flex flex-col items-center justify-center bg-content-0 opacity-0 hover:opacity-90 soft-transition">
              <p class="px-4 text-base font-semibold text-center text-surface-3 opacity-0 group-hover:opacity-100 soft-transition lowercase">{item.title}</p>
              <p class="text-base font-mono font-medium text-surface-4">{item.created.getFullYear()}</p>
              {item.inspiration && (
                <a class="text-sm font-base font-medium italic text-center text-content-4 hover:text-content-3 opacity-0 group-hover:opacity-100 soft-transition"
                  target="_blank"
                  href={item.inspiration}>
                    inspiration
                </a>
              )}
            </div>
          )}
        </masonry-item>
      ))}
    </masonry-list>
  </div>

  <script>
    // Filter logic (same as before)
    const buttons = document.querySelectorAll('.filter-button');
    const items = document.querySelectorAll('masonry-item');
    let activeFilter: string | null = null;

    function formatTag(tag: string): string {
      if (!tag) return '';
      const formatted = tag.replace(/-/g, ' ');
      return formatted;
    }

    buttons.forEach(button => {
      button.addEventListener('click', () => {
        const tag = button.getAttribute('data-tag');
        if (activeFilter === tag) {
          activeFilter = null;
        } else {
          activeFilter = tag;
        }
        // Update buttons
        buttons.forEach(b => {
          const bTag = b.getAttribute('data-tag');
          b.classList.toggle('bg-surface-3', activeFilter === bTag);
          b.classList.toggle('text-content-1', activeFilter === bTag);
          b.classList.toggle('bg-surface-1', activeFilter !== bTag);
          b.classList.toggle('text-content-2', activeFilter !== bTag);
        });
        // Filter items (works with custom element tags!)
        items.forEach(item => {
          const itemTags = item.getAttribute('data-tags')?.split(',').map(formatTag);
          if (!activeFilter || (itemTags && itemTags.includes(activeFilter))) {
            item.classList.remove('hidden');
          } else {
            item.classList.add('hidden');
          }
        });
      });
    });

    // Masonry patch JS (from CodePen, put at the end)
    class MasonryList extends HTMLElement {
      #patched = false;

      get patched() { return this.#patched; }
      connectedCallback() {
        const style = getComputedStyle(this);
        if (style.gridTemplateRows === "masonry") return;
        this.#patched = true;
        this.style.gridAutoRows = "0px";
        this.style.setProperty("--masonry-list-row-gap", `${Math.round(parseFloat(style.rowGap))}`);
        this.style.setProperty("row-gap", "1px", "important");
      }
    }

    class MasonryItem extends HTMLElement {
      #observer = null;
      #layout = () => {
        const { height } = this.getBoundingClientRect();
        this.style.gridRowEnd = `span calc(${Math.round(height)} + var(--masonry-list-row-gap))`;
      };
      connectedCallback() {
        const masonry = this.closest("masonry-list");
        /* @ts-ignore */
        if (!masonry?.patched) return;
        /* @ts-ignore */
        this.#observer = new ResizeObserver(this.#layout);
        /* @ts-ignore */
        this.#observer.observe(this);
        this.#layout();
      }
      /* @ts-ignore */
      disconnectedCallback() { this.#observer?.disconnect(); }
    }

    if (typeof window !== "undefined") {
      customElements.define("masonry-list", MasonryList);
      customElements.define("masonry-item", MasonryItem);
    }
  </script>
</BaseLayout>

<style>
/* Responsive columns for masonry-list */
masonry-list {
  display: grid;
  column-gap: var(--masonry-list-column-gap, 1rem);
  row-gap: var(--masonry-list-row-gap, 1rem);
  grid-template-columns: repeat(auto-fit, minmax(min(30ch, var(--masonry-item-width, 15rem)), 1fr));
  grid-auto-flow: dense;
}
@media (max-width: 40rem) {
  masonry-list { grid-template-columns: 1fr 1fr; }
}
@media (min-width: 40rem) and (max-width: 64rem) {
  masonry-list { grid-template-columns: repeat(3, 1fr); }
}
@media (min-width: 64rem) {
  masonry-list { grid-template-columns: repeat(5, 1fr); }
}
masonry-item {
  align-self: start;
  grid-column-end: span var(--masonry-item-span, 1);
}
</style>